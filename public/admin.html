<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Panel - Camera App</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: #343a40;
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            flex: 1;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid #dee2e6;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #007bff;
        }

        .photos-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
        }

        .photo-card {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .photo-card img {
            width: 100%;
            height: 200px;
            object-fit: cover;
        }

        .photo-info {
            padding: 15px;
        }

        .photo-filename {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .photo-timestamp {
            color: #6c757d;
            font-size: 0.9em;
        }

        .photo-size {
            color: #6c757d;
            font-size: 0.8em;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 15px 20px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .refresh-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 20px;
        }

        .refresh-btn:hover {
            background: #0056b3;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #6c757d;
        }

        .container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid #dee2e6;
        }

        .streams-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
        }

        .stream-card {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .stream-video {
            width: 100%;
            height: 240px;
            background: #000;
        }

        .stream-info {
            padding: 15px;
            text-align: center;
        }

        .stream-status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .status-live {
            background: #d4edda;
            color: #155724;
        }

        .status-connecting {
            background: #fff3cd;
            color: #856404;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>📊 Admin Panel</h1>
        <p>Real-time monitoring of captured photos and live camera streams</p>
    </div>

    <div class="container" id="liveStreamSection">
        <h2>🔴 Live Camera Streams</h2>
        <div id="streamsContainer">
            <div class="loading">No active camera streams</div>
        </div>
    </div>

    <div class="stats">
        <div class="stat-card">
            <div class="stat-number" id="totalPhotos">0</div>
            <div>Total Photos</div>
        </div>
        <div class="stat-card">
            <div class="stat-number" id="totalSize">0 KB</div>
            <div>Total Size</div>
        </div>
        <div class="stat-card">
            <div class="stat-number" id="lastPhoto">Never</div>
            <div>Last Photo</div>
        </div>
    </div>

    <button class="refresh-btn" onclick="loadPhotos()">🔄 Refresh</button>

    <div id="photosContainer">
        <div class="loading">Loading photos...</div>
    </div>

    <div id="notification" class="notification"></div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        let photos = [];
        let activeStreams = new Map();
        let peerConnections = new Map();
        let pendingIceCandidates = new Map(); // Queue ICE candidates until remote description is set

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function formatTimestamp(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleString();
        }

        function showNotification(message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.classList.add('show');

            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        function updateStats() {
            const totalPhotos = photos.length;
            const totalSize = photos.reduce((sum, photo) => sum + photo.size, 0);
            const lastPhoto = photos.length > 0 ? photos[0].timestamp : null;

            document.getElementById('totalPhotos').textContent = totalPhotos;
            document.getElementById('totalSize').textContent = formatFileSize(totalSize);
            document.getElementById('lastPhoto').textContent = lastPhoto ?
                formatTimestamp(lastPhoto) : 'Never';
        }

        function renderPhotos() {
            const container = document.getElementById('photosContainer');

            if (photos.length === 0) {
                container.innerHTML = '<div class="loading">No photos captured yet</div>';
                return;
            }

            const photosHTML = photos.map(photo => `
                <div class="photo-card">
                    <img src="/uploads/${photo.filename}" alt="Captured photo" loading="lazy">
                    <div class="photo-info">
                        <div class="photo-filename">${photo.filename}</div>
                        <div class="photo-timestamp">${formatTimestamp(photo.timestamp)}</div>
                        <div class="photo-size">${formatFileSize(photo.size)}</div>
                    </div>
                </div>
            `).join('');

            container.innerHTML = `<div class="photos-grid">${photosHTML}</div>`;
        }

        async function loadPhotos() {
            try {
                const response = await fetch('/api/photos');
                photos = await response.json();
                updateStats();
                renderPhotos();
            } catch (error) {
                console.error('Failed to load photos:', error);
                document.getElementById('photosContainer').innerHTML =
                    '<div class="loading">Failed to load photos</div>';
            }
        }

        // WebRTC functions
        async function createPeerConnection(clientId) {
            const pc = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            });

            // Handle incoming stream
            pc.ontrack = (event) => {
                console.log('Received stream from client:', clientId);
                const stream = event.streams[0];
                displayStream(clientId, stream);
            };

            // Handle ICE candidates
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('Sending ICE candidate to client:', clientId);
                    socket.emit('ice-candidate', {
                        candidate: event.candidate,
                        target: clientId
                    });
                } else {
                    console.log('ICE gathering complete for client:', clientId);
                }
            };

            // Handle connection state changes
            pc.onconnectionstatechange = () => {
                console.log('Connection state with client', clientId, ':', pc.connectionState);
                if (pc.connectionState === 'connected') {
                    updateStreamStatus(clientId, 'live');
                } else if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
                    updateStreamStatus(clientId, 'connecting');
                }
            };

            pc.oniceconnectionstatechange = () => {
                console.log('ICE connection state with client', clientId, ':', pc.iceConnectionState);
            };

            peerConnections.set(clientId, pc);
            return pc;
        }

        async function requestStream(clientId) {
            console.log('Requesting stream from client:', clientId);

            try {
                const pc = await createPeerConnection(clientId);

                const offer = await pc.createOffer({
                    offerToReceiveVideo: true,
                    offerToReceiveAudio: false
                });
                await pc.setLocalDescription(offer);

                console.log('Sending offer to client:', clientId);
                socket.emit('offer', {
                    offer: offer,
                    target: clientId
                });

                // Update UI to show connecting status
                updateStreamStatus(clientId, 'connecting');
            } catch (error) {
                console.error('Error requesting stream from client:', clientId, error);
                showNotification(`Failed to connect to camera: ${error.message}`);
            }
        }

        function displayStream(clientId, stream) {
            const video = document.getElementById(`stream-${clientId}`);
            if (video) {
                video.srcObject = stream;
                updateStreamStatus(clientId, 'live');
            }
        }

        function updateStreamStatus(clientId, status) {
            const statusElement = document.getElementById(`status-${clientId}`);
            if (statusElement) {
                statusElement.textContent = status === 'live' ? 'LIVE' : 'CONNECTING...';
                statusElement.className = `stream-status status-${status}`;
            }
        }

        function renderStreams() {
            const container = document.getElementById('streamsContainer');

            if (activeStreams.size === 0) {
                container.innerHTML = '<div class="loading">No active camera streams</div>';
                return;
            }

            const streamsHTML = Array.from(activeStreams.keys()).map(clientId => `
                <div class="stream-card">
                    <video id="stream-${clientId}" class="stream-video" autoplay playsinline muted></video>
                    <div class="stream-info">
                        <div>Camera: ${clientId.substring(0, 8)}...</div>
                        <span id="status-${clientId}" class="stream-status status-connecting">CONNECTING...</span>
                        <br>
                        <button onclick="retryConnection('${clientId}')" style="margin-top: 5px; padding: 5px 10px; font-size: 12px;">Retry</button>
                    </div>
                </div>
            `).join('');

            container.innerHTML = `<div class="streams-grid">${streamsHTML}</div>`;
        }

        // Socket.IO event listeners
        socket.on('connect', () => {
            console.log('Admin connected to server');
            console.log('Admin URL:', window.location.href);
            console.log('Protocol:', window.location.protocol);
            socket.emit('admin-ready');
        });
        
        socket.on('connect_error', (error) => {
            console.error('Socket connection error:', error);
            showNotification('Connection failed. Make sure both client and admin use HTTPS.');
        });

        socket.on('camera-available', (data) => {
            console.log('New camera available:', data.clientId);
            activeStreams.set(data.clientId, { status: 'available' });
            renderStreams();

            // Add a small delay to ensure client is ready
            setTimeout(() => {
                requestStream(data.clientId);
                
                // Set a timeout to retry if connection doesn't establish
                setTimeout(() => {
                    const pc = peerConnections.get(data.clientId);
                    if (pc && pc.connectionState !== 'connected') {
                        console.log('Connection timeout, retrying...');
                        retryConnection(data.clientId);
                    }
                }, 10000); // 10 second timeout
            }, 2000); // Increased delay to 2 seconds

            showNotification(`New camera connected: ${data.clientId.substring(0, 8)}...`);
        });

        socket.on('camera-disconnected', (data) => {
            console.log('Camera disconnected:', data.clientId);
            activeStreams.delete(data.clientId);
            
            // Clean up peer connection and pending candidates
            const pc = peerConnections.get(data.clientId);
            if (pc) {
                pc.close();
                peerConnections.delete(data.clientId);
            }
            pendingIceCandidates.delete(data.clientId);
            
            renderStreams();
            showNotification(`Camera disconnected: ${data.clientId.substring(0, 8)}...`);
        });

        socket.on('available-cameras', (cameras) => {
            console.log('Available cameras:', cameras);
            cameras.forEach(clientId => {
                activeStreams.set(clientId, { status: 'available' });
                requestStream(clientId);
            });
            renderStreams();
        });

        socket.on('answer', async (data) => {
            console.log('=== RECEIVED ANSWER FROM CLIENT ===');
            console.log('Client ID:', data.sender);
            console.log('Answer SDP:', data.answer);
            
            const pc = peerConnections.get(data.sender);
            if (pc) {
                try {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                    console.log('✅ Set remote description (answer) successfully');
                    
                    // Process any queued ICE candidates
                    const queuedCandidates = pendingIceCandidates.get(data.sender) || [];
                    console.log('Processing', queuedCandidates.length, 'queued ICE candidates');
                    
                    for (const candidate of queuedCandidates) {
                        try {
                            await pc.addIceCandidate(candidate);
                            console.log('✅ Added queued ICE candidate successfully');
                        } catch (error) {
                            console.error('❌ Error adding queued ICE candidate:', error);
                        }
                    }
                    
                    // Clear the queue
                    pendingIceCandidates.delete(data.sender);
                } catch (error) {
                    console.error('❌ Error setting remote description:', error);
                }
            } else {
                console.error('❌ No peer connection found for client:', data.sender);
            }
        });

        socket.on('ice-candidate', async (data) => {
            console.log('Received ICE candidate from client:', data.sender);
            const pc = peerConnections.get(data.sender);
            if (pc) {
                // Check if remote description is set
                if (pc.remoteDescription) {
                    try {
                        await pc.addIceCandidate(data.candidate);
                        console.log('Added ICE candidate successfully');
                    } catch (error) {
                        console.error('Error adding ICE candidate:', error);
                    }
                } else {
                    // Queue the ICE candidate until remote description is set
                    console.log('Queueing ICE candidate (no remote description yet)');
                    if (!pendingIceCandidates.has(data.sender)) {
                        pendingIceCandidates.set(data.sender, []);
                    }
                    pendingIceCandidates.get(data.sender).push(data.candidate);
                }
            }
        });

        socket.on('camera-switched', (data) => {
            console.log('Camera switched:', data.clientId, 'to:', data.cameraName);
            showNotification(`Camera switched to: ${data.cameraName}`);
        });
        
        socket.on('new-photo', (photoData) => {
            photos.unshift(photoData);
            updateStats();
            renderPhotos();
            showNotification(`New photo captured: ${photoData.filename}`);
        });

        // Retry connection function
        function retryConnection(clientId) {
            console.log('Retrying connection to client:', clientId);
            
            // Close existing connection
            const existingPc = peerConnections.get(clientId);
            if (existingPc) {
                existingPc.close();
                peerConnections.delete(clientId);
            }
            
            // Clear any pending ICE candidates
            pendingIceCandidates.delete(clientId);
            
            // Update status and retry
            updateStreamStatus(clientId, 'connecting');
            setTimeout(() => {
                requestStream(clientId);
            }, 500);
        }
        
        // Load photos on page load
        loadPhotos();
    </script>
</body>

</html>