<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera Recording App</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
        }

        .container {
            background: #f5f5f5;
            padding: 30px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .camera-selector {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid #ddd;
        }

        .camera-option {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            margin: 8px 0;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #f8f9fa;
        }

        .camera-option:hover {
            border-color: #007bff;
            background: #e3f2fd;
        }

        .camera-option.active {
            border-color: #007bff;
            background: #e3f2fd;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
        }

        .camera-option input[type="radio"] {
            margin-right: 12px;
            transform: scale(1.2);
        }

        .camera-label {
            flex: 1;
            font-weight: 500;
            color: #333;
        }

        .camera-info {
            font-size: 0.85em;
            color: #666;
            margin-left: auto;
        }

        .camera-selector h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 1.1em;
        }

        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        video {
            width: 100%;
            max-width: 640px;
            border: 2px solid #ddd;
            border-radius: 10px;
            margin: 20px 0;
        }

        canvas {
            display: none;
        }

        .status {
            margin: 20px 0;
            padding: 10px;
            border-radius: 5px;
        }

        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
    </style>
</head>

<body>
    <h1>üì∏ Camera Recording App</h1>

    <div class="container">
        <h2>Step 1: Start Camera</h2>
        <button id="startBtn">Start Recording</button>
        <div id="status"></div>
    </div>

    <div class="container" id="cameraSection" style="display: none;">
        <h2>Step 2: Camera Controls</h2>

        <div class="camera-selector" id="cameraSelector" style="display: none;">
            <h3>üìπ Select Camera</h3>
            <div id="cameraOptions">
                <!-- Camera options will be populated here -->
            </div>
        </div>

        <video id="video" autoplay playsinline muted></video>
        <br>
        <button id="captureBtn">üì∏ Take Photo</button>
        <button id="stopBtn">‚èπÔ∏è Stop Camera</button>
        <canvas id="canvas"></canvas>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const startBtn = document.getElementById('startBtn');
        const captureBtn = document.getElementById('captureBtn');
        const stopBtn = document.getElementById('stopBtn');
        const cameraSelector = document.getElementById('cameraSelector');
        const cameraOptions = document.getElementById('cameraOptions');
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const status = document.getElementById('status');
        const cameraSection = document.getElementById('cameraSection');

        let stream = null;
        let socket = null;
        let peerConnections = new Map();
        let pendingIceCandidates = new Map(); // Queue ICE candidates until remote description is set
        let availableCameras = [];
        let currentCameraId = null;

        function showStatus(message, type = 'success') {
            status.innerHTML = `<div class="${type}">${message}</div>`;
        }

        // Check if we're on HTTPS or localhost
        function checkSecureContext() {
            const isSecure = location.protocol === 'https:' ||
                location.hostname === 'localhost' ||
                location.hostname === '127.0.0.1';

            if (!isSecure) {
                showStatus('Camera access requires HTTPS. Please access this page via HTTPS or localhost.', 'error');
                return false;
            }
            return true;
        }

        // Check secure context on page load
        if (!checkSecureContext()) {
            startBtn.disabled = true;
        }

        // Initialize WebSocket connection
        function initializeSocket() {
            socket = io();

            socket.on('connect', () => {
                console.log('Client connected to server');
                console.log('Client URL:', window.location.href);
                console.log('Protocol:', window.location.protocol);
            });

            socket.on('connect_error', (error) => {
                console.error('Socket connection error:', error);
                showStatus('Connection failed. Make sure you are using HTTPS.', 'error');
            });

            socket.on('offer', async (data) => {
                console.log('=== RECEIVED OFFER FROM ADMIN ===');
                console.log('Admin ID:', data.sender);
                console.log('Current stream state:', stream ? 'Available' : 'Not available');
                console.log('Stream tracks:', stream ? stream.getTracks().length : 0);
                console.log('Offer SDP:', data.offer);

                if (!stream) {
                    console.error('ERROR: No stream available to send to admin!');
                    return;
                }

                await handleOffer(data.offer, data.sender);
            });

            socket.on('ice-candidate', (data) => {
                console.log('Received ICE candidate from admin:', data.sender);
                handleIceCandidate(data.candidate, data.sender);
            });
        }

        // WebRTC functions
        async function createPeerConnection(adminId) {
            const pc = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            });

            // Add local stream to peer connection
            if (stream && stream.getTracks().length > 0) {
                stream.getTracks().forEach(track => {
                    console.log('Adding track to peer connection:', track.kind, track.readyState);
                    pc.addTrack(track, stream);
                });
                console.log('Added', stream.getTracks().length, 'tracks to peer connection');
            } else {
                console.error('No stream or tracks available for peer connection!');
            }

            // Handle ICE candidates
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('Sending ICE candidate to admin:', adminId);
                    socket.emit('ice-candidate', {
                        candidate: event.candidate,
                        target: adminId
                    });
                } else {
                    console.log('ICE gathering complete for admin:', adminId);
                }
            };

            // Handle connection state changes
            pc.onconnectionstatechange = () => {
                console.log('Connection state with admin', adminId, ':', pc.connectionState);
            };

            pc.oniceconnectionstatechange = () => {
                console.log('ICE connection state with admin', adminId, ':', pc.iceConnectionState);
            };

            peerConnections.set(adminId, pc);
            return pc;
        }

        async function handleOffer(offer, adminId) {
            try {
                console.log('=== HANDLING OFFER ===');
                console.log('Creating peer connection for admin:', adminId);

                const pc = await createPeerConnection(adminId);
                console.log('Peer connection created successfully');

                console.log('Setting remote description (offer)...');
                await pc.setRemoteDescription(new RTCSessionDescription(offer));
                console.log('‚úÖ Set remote description successfully');

                // Process any queued ICE candidates
                const queuedCandidates = pendingIceCandidates.get(adminId) || [];
                console.log('Processing', queuedCandidates.length, 'queued ICE candidates');

                for (const candidate of queuedCandidates) {
                    try {
                        await pc.addIceCandidate(candidate);
                        console.log('‚úÖ Added queued ICE candidate successfully');
                    } catch (error) {
                        console.error('‚ùå Error adding queued ICE candidate:', error);
                    }
                }

                // Clear the queue
                pendingIceCandidates.delete(adminId);

                console.log('Creating answer...');
                const answer = await pc.createAnswer();
                console.log('Answer created:', answer);

                console.log('Setting local description (answer)...');
                await pc.setLocalDescription(answer);
                console.log('‚úÖ Set local description successfully');

                console.log('Sending answer to admin via socket...');
                socket.emit('answer', {
                    answer: answer,
                    target: adminId
                });
                console.log('‚úÖ Answer sent to admin:', adminId);

            } catch (error) {
                console.error('‚ùå CRITICAL ERROR handling offer:', error);
                console.error('Error stack:', error.stack);
            }
        }

        async function handleIceCandidate(candidate, adminId) {
            const pc = peerConnections.get(adminId);
            if (pc) {
                // Check if remote description is set
                if (pc.remoteDescription) {
                    try {
                        await pc.addIceCandidate(candidate);
                        console.log('Added ICE candidate successfully');
                    } catch (error) {
                        console.error('Error adding ICE candidate:', error);
                    }
                } else {
                    // Queue the ICE candidate until remote description is set
                    console.log('Queueing ICE candidate (no remote description yet)');
                    if (!pendingIceCandidates.has(adminId)) {
                        pendingIceCandidates.set(adminId, []);
                    }
                    pendingIceCandidates.get(adminId).push(candidate);
                }
            }
        }

        // Camera enumeration and selection
        async function enumerateCameras() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                availableCameras = devices.filter(device => device.kind === 'videoinput');

                // Populate camera options with radio buttons
                renderCameraOptions();

                console.log('Available cameras:', availableCameras);
                return availableCameras.length > 0;
            } catch (error) {
                console.error('Error enumerating cameras:', error);
                return false;
            }
        }

        function renderCameraOptions() {
            cameraOptions.innerHTML = '';

            if (availableCameras.length === 0) {
                cameraOptions.innerHTML = '<p style="color: #666; text-align: center;">No cameras detected</p>';
                return;
            }

            availableCameras.forEach((camera, index) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'camera-option';

                const radioId = `camera-${camera.deviceId}`;
                const isActive = camera.deviceId === currentCameraId;

                if (isActive) {
                    optionDiv.classList.add('active');
                }

                // Determine camera type for better labeling
                const label = camera.label || `Camera ${index + 1}`;
                let cameraType = '';
                if (label.toLowerCase().includes('front') || label.toLowerCase().includes('user')) {
                    cameraType = 'ü§≥ Front';
                } else if (label.toLowerCase().includes('back') || label.toLowerCase().includes('environment')) {
                    cameraType = 'üì∑ Back';
                } else {
                    cameraType = 'üìπ Camera';
                }

                optionDiv.innerHTML = `
                    <input type="radio" 
                           id="${radioId}" 
                           name="cameraSelection" 
                           value="${camera.deviceId}"
                           ${isActive ? 'checked' : ''}>
                    <label for="${radioId}" class="camera-label">${label}</label>
                    <span class="camera-info">${cameraType}</span>
                `;

                // Add click handler for the entire div
                optionDiv.addEventListener('click', (e) => {
                    if (e.target.type !== 'radio') {
                        const radio = optionDiv.querySelector('input[type="radio"]');
                        radio.checked = true;
                        handleCameraChange(camera.deviceId);
                    }
                });

                // Add change handler for the radio button
                const radio = optionDiv.querySelector('input[type="radio"]');
                radio.addEventListener('change', () => {
                    if (radio.checked) {
                        handleCameraChange(camera.deviceId);
                    }
                });

                cameraOptions.appendChild(optionDiv);
            });

            // Show camera selector if multiple cameras available
            if (availableCameras.length > 1) {
                cameraSelector.style.display = 'block';
            }
        }

        async function handleCameraChange(deviceId) {
            if (deviceId && deviceId !== currentCameraId) {
                try {
                    showStatus('üîÑ Switching camera...');

                    // Update active state in UI
                    document.querySelectorAll('.camera-option').forEach(option => {
                        option.classList.remove('active');
                    });

                    const selectedOption = document.querySelector(`input[value="${deviceId}"]`).closest('.camera-option');
                    selectedOption.classList.add('active');

                    await startCamera(deviceId);

                    const cameraName = availableCameras.find(cam => cam.deviceId === deviceId)?.label || 'Selected Camera';
                    showStatus(`‚úÖ Switched to: ${cameraName}`);
                    console.log('‚úÖ Camera switched successfully, streams updated');

                    // Notify admin about camera switch
                    socket.emit('camera-switched', {
                        cameraName: cameraName
                    });
                } catch (error) {
                    showStatus(`‚ùå Failed to switch camera: ${error.message}`, 'error');
                    console.error('‚ùå Camera switch failed:', error);

                    // Revert radio button selection
                    if (currentCameraId) {
                        const currentRadio = document.querySelector(`input[value="${currentCameraId}"]`);
                        if (currentRadio) {
                            currentRadio.checked = true;
                            currentRadio.closest('.camera-option').classList.add('active');
                        }
                    }
                }
            }
        }

        async function startCamera(deviceId = null) {
            try {
                // Stop existing stream
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }

                let constraints = {
                    video: {
                        width: { ideal: 640, min: 320, max: 1920 },
                        height: { ideal: 480, min: 240, max: 1080 },
                        frameRate: { ideal: 30, min: 10, max: 60 }
                    },
                    audio: false
                };

                // Add device constraint if specified
                if (deviceId) {
                    console.log('üéØ Trying to start specific camera:', deviceId);
                    
                    // Try with exact device ID first
                    constraints.video.deviceId = { exact: deviceId };
                    
                    try {
                        stream = await navigator.mediaDevices.getUserMedia(constraints);
                        currentCameraId = deviceId;
                        console.log('‚úÖ Started camera with exact constraint');
                    } catch (exactError) {
                        console.warn('‚ö†Ô∏è Exact device constraint failed, trying ideal:', exactError.name);
                        
                        // Fallback to ideal constraint
                        constraints.video.deviceId = { ideal: deviceId };
                        
                        try {
                            stream = await navigator.mediaDevices.getUserMedia(constraints);
                            currentCameraId = deviceId;
                            console.log('‚úÖ Started camera with ideal constraint');
                        } catch (idealError) {
                            console.warn('‚ö†Ô∏è Ideal constraint failed, trying basic video:', idealError.name);
                            
                            // Last fallback - just basic video
                            constraints = { video: true, audio: false };
                            stream = await navigator.mediaDevices.getUserMedia(constraints);
                            
                            // Try to get the actual device ID
                            const track = stream.getVideoTracks()[0];
                            if (track && track.getSettings) {
                                const settings = track.getSettings();
                                currentCameraId = settings.deviceId || null;
                            }
                            console.log('‚úÖ Started camera with basic constraints');
                        }
                    }
                } else {
                    console.log('üéØ Starting default camera');
                    
                    try {
                        // Don't specify exact device for initial start
                        stream = await navigator.mediaDevices.getUserMedia(constraints);
                        
                        // Get the actual device ID that was selected
                        const track = stream.getVideoTracks()[0];
                        if (track && track.getSettings) {
                            const settings = track.getSettings();
                            currentCameraId = settings.deviceId || null;
                            console.log('‚úÖ Started default camera, device ID:', currentCameraId);
                        }
                    } catch (constraintError) {
                        console.warn('‚ö†Ô∏è Detailed constraints failed, trying basic:', constraintError.name);
                        
                        // Fallback to very basic constraints
                        constraints = { video: true, audio: false };
                        stream = await navigator.mediaDevices.getUserMedia(constraints);
                        
                        const track = stream.getVideoTracks()[0];
                        if (track && track.getSettings) {
                            const settings = track.getSettings();
                            currentCameraId = settings.deviceId || null;
                        }
                        console.log('‚úÖ Started camera with basic fallback');
                    }
                }

                video.srcObject = stream;

                // Log stream info for debugging
                const track = stream.getVideoTracks()[0];
                if (track) {
                    console.log('üìπ Stream info:', {
                        label: track.label,
                        settings: track.getSettings ? track.getSettings() : 'Not available',
                        constraints: track.getConstraints ? track.getConstraints() : 'Not available'
                    });
                }

                // Update peer connections with new stream
                updatePeerConnectionStreams();

                return true;
            } catch (error) {
                console.error('‚ùå Error starting camera:', error);
                console.error('Error name:', error.name);
                console.error('Error message:', error.message);
                
                // Provide user-friendly error messages
                let userMessage = 'Failed to start camera';
                if (error.name === 'OverconstrainedError') {
                    userMessage = 'Camera settings not supported. Trying with different settings...';
                } else if (error.name === 'NotAllowedError') {
                    userMessage = 'Camera access denied. Please allow camera permissions.';
                } else if (error.name === 'NotFoundError') {
                    userMessage = 'No camera found. Please connect a camera.';
                }
                
                throw new Error(userMessage);
            }
        }

        async function updatePeerConnectionStreams() {
            if (stream && peerConnections.size > 0) {
                console.log('=== UPDATING PEER CONNECTION STREAMS ===');
                console.log('Active peer connections:', peerConnections.size);

                for (const [adminId, pc] of peerConnections) {
                    try {
                        // Remove old tracks
                        const senders = pc.getSenders();
                        console.log('Removing', senders.length, 'old tracks for admin:', adminId);

                        for (const sender of senders) {
                            if (sender.track) {
                                await sender.replaceTrack(null);
                            }
                        }

                        // Add new tracks
                        const newTracks = stream.getTracks();
                        console.log('Adding', newTracks.length, 'new tracks for admin:', adminId);

                        for (let i = 0; i < newTracks.length; i++) {
                            const track = newTracks[i];
                            if (i < senders.length) {
                                // Replace existing sender's track
                                await senders[i].replaceTrack(track);
                                console.log('‚úÖ Replaced track for sender', i);
                            } else {
                                // Add new sender if needed
                                pc.addTrack(track, stream);
                                console.log('‚úÖ Added new track');
                            }
                        }

                        console.log('‚úÖ Updated streams for admin:', adminId);
                    } catch (error) {
                        console.error('‚ùå Error updating streams for admin:', adminId, error);
                    }
                }
            }
        }

        // Camera switching is now handled by radio button change events

        // Initialize socket connection
        initializeSocket();

        startBtn.addEventListener('click', async () => {
            try {
                // Debug information
                console.log('Navigator object:', navigator);
                console.log('MediaDevices:', navigator.mediaDevices);
                console.log('Protocol:', location.protocol);
                console.log('Hostname:', location.hostname);

                // First enumerate cameras
                showStatus('Enumerating cameras...');
                await enumerateCameras();

                // Check if getUserMedia is supported
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    // Try older API as fallback
                    const getUserMedia = navigator.getUserMedia ||
                        navigator.webkitGetUserMedia ||
                        navigator.mozGetUserMedia ||
                        navigator.msGetUserMedia;

                    if (!getUserMedia) {
                        throw new Error('Camera access is not supported in this browser. Please use Chrome, Firefox, or Safari.');
                    }

                    // Use callback-based API
                    getUserMedia.call(navigator,
                        { video: { width: 640, height: 480 }, audio: false },
                        async (mediaStream) => {
                            stream = mediaStream;
                            video.srcObject = stream;
                            cameraSection.style.display = 'block';
                            startBtn.disabled = true;

                            // Enumerate cameras after getting permission
                            await enumerateCameras();

                            showStatus('üìπ Camera started successfully! Live streaming to admin panel...');

                            // Wait a bit for stream to be fully ready, then notify server
                            setTimeout(() => {
                                console.log('=== NOTIFYING SERVER CLIENT IS READY ===');
                                console.log('Socket connected:', socket.connected);
                                console.log('Socket ID:', socket.id);
                                socket.emit('client-ready');
                                console.log('‚úÖ client-ready event sent');
                            }, 1000);
                        },
                        (error) => {
                            showStatus(`Error accessing camera: ${error.message}`, 'error');
                        }
                    );
                } else {
                    // Use modern API
                    await startCamera();

                    cameraSection.style.display = 'block';
                    startBtn.disabled = true;

                    // Update camera options to show current selection
                    renderCameraOptions();

                    showStatus('üìπ Camera started successfully! Live streaming to admin panel...');

                    // Wait a bit for stream to be fully ready, then notify server
                    setTimeout(() => {
                        console.log('=== NOTIFYING SERVER CLIENT IS READY ===');
                        console.log('Socket connected:', socket.connected);
                        console.log('Socket ID:', socket.id);
                        socket.emit('client-ready');
                        console.log('‚úÖ client-ready event sent');
                    }, 1000);
                }

            } catch (error) {
                let errorMessage = error.message;

                // Provide more helpful error messages
                if (error.name === 'NotAllowedError') {
                    errorMessage = 'Camera access denied. Please allow camera permissions and try again.';
                } else if (error.name === 'NotFoundError') {
                    errorMessage = 'No camera found. Please connect a camera and try again.';
                } else if (error.name === 'NotSupportedError') {
                    errorMessage = 'Camera access is not supported in this browser.';
                } else if (error.name === 'NotReadableError') {
                    errorMessage = 'Camera is already in use by another application.';
                } else if (error.name === 'OverconstrainedError') {
                    errorMessage = 'Camera settings not supported. The app will try with basic settings.';
                    console.log('OverconstrainedError details:', error.constraint);
                }

                showStatus(`Error accessing camera: ${errorMessage}`, 'error');
                console.error('Full error details:', error);
            }
        });

        captureBtn.addEventListener('click', () => {
            const context = canvas.getContext('2d');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            context.drawImage(video, 0, 0);

            canvas.toBlob(async (blob) => {
                const formData = new FormData();
                formData.append('photo', blob, 'photo.png');

                try {
                    const response = await fetch('/upload-photo', {
                        method: 'POST',
                        body: formData
                    });

                    const result = await response.json();

                    if (result.success) {
                        showStatus(`Photo captured and saved as ${result.photo.filename}`);
                    } else {
                        showStatus('Failed to save photo', 'error');
                    }
                } catch (error) {
                    showStatus(`Upload error: ${error.message}`, 'error');
                }
            }, 'image/png');
        });

        stopBtn.addEventListener('click', () => {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                video.srcObject = null;
                cameraSection.style.display = 'none';
                startBtn.disabled = false;
                showStatus('Camera stopped');

                // Close all peer connections
                peerConnections.forEach(pc => pc.close());
                peerConnections.clear();
                pendingIceCandidates.clear();

                // Notify server that camera is stopped
                socket.emit('client-stopped');
            }
        });
    </script>
</body>

</html>